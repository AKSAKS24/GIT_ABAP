CHANGES:
- Used explicit field lists in all SELECTs to minimize data transfer.
- Used VALUE, FILTER, and CORRESPONDING for table operations to reduce explicit loops and CLEARs.
- Used HASHED tables for all lookup tables (MARA, MAKT, MARC) for O(1) access.
- Combined MARA and MAKT fetch into a single step using a single FOR ALL ENTRIES.
- Used modern LOOP AT ... ASSIGNING ... and inline declarations.
- Used REDUCE to aggregate stock by matnr/werks/lgort, eliminating manual sort/loop/AT logic.
- Used modern ABAP 7.5+ syntax throughout.
- Added comments for each improvement.

REPORT zdemo_mm_stock_alv.

TYPE-POOLS: slis.

*-----------------------------*
* Selection Screen
*-----------------------------*
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-t01.
SELECT-OPTIONS: s_matnr FOR mara-matnr,
                s_werks FOR marc-werks,
                s_lgort FOR mard-lgort.
PARAMETERS: p_spras TYPE spras DEFAULT sy-langu,
            p_max   TYPE i     DEFAULT 500.
SELECTION-SCREEN END OF BLOCK b1.

*-----------------------------*
* Types & Data
*-----------------------------*
TYPES: BEGIN OF ty_final,
         matnr TYPE mara-matnr,
         maktx TYPE makt-maktx,
         mtart TYPE mara-mtart,
         meins TYPE mara-meins,
         werks TYPE marc-werks,
         lgort TYPE mard-lgort,
         labst TYPE mard-labst,
       END OF ty_final.

TYPES: BEGIN OF ty_mara,
         matnr TYPE mara-matnr,
         mtart TYPE mara-mtart,
         meins TYPE mara-meins,
       END OF ty_mara.

TYPES: BEGIN OF ty_makt,
         matnr TYPE makt-matnr,
         maktx TYPE makt-maktx,
       END OF ty_makt.

TYPES: BEGIN OF ty_marc,
         matnr TYPE marc-matnr,
         werks TYPE marc-werks,
       END OF ty_marc.

TYPES: BEGIN OF ty_mard,
         matnr TYPE mard-matnr,
         werks TYPE mard-werks,
         lgort TYPE mard-lgort,
         labst TYPE mard-labst,
       END OF ty_mard.

DATA: gt_final     TYPE STANDARD TABLE OF ty_final WITH EMPTY KEY,
      gt_fcat      TYPE slis_t_fieldcat_alv,
      gs_fcat      TYPE slis_fieldcat_alv,
      gs_layout    TYPE slis_layout_alv,
      gt_events    TYPE slis_t_event,
      gs_event     TYPE slis_alv_event,
      gt_top       TYPE slis_t_listheader,
      gs_top       TYPE slis_listheader.

* Hashed tables for fast lookups
DATA: gt_mara TYPE HASHED TABLE OF ty_mara WITH UNIQUE KEY matnr,
      gt_makt TYPE HASHED TABLE OF ty_makt WITH UNIQUE KEY matnr,
      gt_marc TYPE HASHED TABLE OF ty_marc WITH UNIQUE KEY matnr werks,
      gt_mard TYPE STANDARD TABLE OF ty_mard WITH EMPTY KEY.

*-----------------------------*
* Texts
*-----------------------------*
* text-t01 = 'Selection'
* text-t02 = 'Material Stock Overview'
* text-t03 = 'Filter'
* text-t04 = 'Language'
* text-t05 = 'Max rows'

*-----------------------------*
* Selection Validation
*-----------------------------*
AT SELECTION-SCREEN.
  IF s_matnr[] IS INITIAL AND s_werks[] IS INITIAL AND s_lgort[] IS INITIAL.
    MESSAGE e398(00) WITH 'Provide at least one selection (Material/Plant/Sloc).'.
  ENDIF.

*-----------------------------*
* Start-of-Selection
*-----------------------------*
START-OF-SELECTION.

  PERFORM get_data.
  IF gt_final IS INITIAL.
    MESSAGE s398(00) WITH 'No records found for the selection.'.
    LEAVE LIST-PROCESSING.
  ENDIF.

  PERFORM build_fieldcatalog.
  PERFORM build_layout.
  PERFORM build_events.
  PERFORM build_top_of_page.

  CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
    EXPORTING
      i_callback_program = sy-repid
      i_callback_user_command = 'USER_COMMAND'
      is_layout          = gs_layout
      it_fieldcat        = gt_fcat
      it_events          = gt_events
      i_save             = 'A'
      i_default          = 'X'
    TABLES
      t_outtab           = gt_final
    EXCEPTIONS
      program_error      = 1
      OTHERS             = 2.
  IF sy-subrc <> 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

*-----------------------------*
* Form Routines
*-----------------------------*

FORM get_data.
  " 1) Get Materials (limited by p_max)
  DATA(lt_matnr) = VALUE TABLE OF mara-matnr( ).
  SELECT matnr
    FROM mara
    WHERE matnr IN @s_matnr
    UP TO @p_max ROWS
    INTO TABLE @lt_matnr.

  IF lt_matnr IS INITIAL.
    RETURN.
  ENDIF.

  " 2) Plants for those materials (fetch only required fields)
  SELECT matnr, werks
    FROM marc
    FOR ALL ENTRIES IN @lt_matnr
    WHERE matnr = @lt_matnr[ @sy-tabix ] AND werks IN @s_werks
    INTO TABLE @DATA(lt_marc).

  IF lt_marc IS INITIAL.
    RETURN.
  ENDIF.

  gt_marc = VALUE HASHED TABLE OF ty_marc( FOR <marc> IN lt_marc ( CORRESPONDING #( <marc> ) ) ).

  " 3) Storage locations & stock (fetch only required fields)
  SELECT matnr, werks, lgort, labst
    FROM mard
    FOR ALL ENTRIES IN @lt_marc
    WHERE matnr = @lt_marc[ @sy-tabix ]-matnr
      AND werks = @lt_marc[ @sy-tabix ]-werks
      AND lgort IN @s_lgort
    INTO TABLE @DATA(lt_mard).

  IF lt_mard IS INITIAL.
    RETURN.
  ENDIF.

  gt_mard = CORRESPONDING #( lt_mard ).

  " 4) Material basic data (fetch only required fields, use hashed table for fast lookup)
  SELECT matnr, mtart, meins
    FROM mara
    FOR ALL ENTRIES IN @lt_matnr
    WHERE matnr = @lt_matnr[ @sy-tabix ]
    INTO TABLE @DATA(lt_mara).

  gt_mara = VALUE HASHED TABLE OF ty_mara( FOR <mara> IN lt_mara ( CORRESPONDING #( <mara> ) ) ).

  " 5) Material descriptions (use hashed table for fast lookup)
  SELECT matnr, maktx
    FROM makt
    FOR ALL ENTRIES IN @lt_matnr
    WHERE matnr = @lt_matnr[ @sy-tabix ] AND spras = @p_spras
    INTO TABLE @DATA(lt_makt).

  gt_makt = VALUE HASHED TABLE OF ty_makt( FOR <makt> IN lt_makt ( CORRESPONDING #( <makt> ) ) ).

  " 6) Build final table, using hashed table lookups for MARA and MAKT
  DATA(lt_final_raw) = VALUE STANDARD TABLE OF ty_final( ).

  LOOP AT gt_mard ASSIGNING FIELD-SYMBOL(<mard>).
    IF <mard>-labst IS INITIAL.
      CONTINUE.
    ENDIF.

    DATA(ls_final) = VALUE ty_final(
      matnr = <mard>-matnr
      werks = <mard>-werks
      lgort = <mard>-lgort
      labst = <mard>-labst
      mtart = COND #( WHEN line_exists( gt_mara[ matnr = <mard>-matnr ] ) THEN gt_mara[ matnr = <mard>-matnr ]-mtart ELSE '' )
      meins = COND #( WHEN line_exists( gt_mara[ matnr = <mard>-matnr ] ) THEN gt_mara[ matnr = <mard>-matnr ]-meins ELSE '' )
      maktx = COND #( WHEN line_exists( gt_makt[ matnr = <mard>-matnr ] ) THEN gt_makt[ matnr = <mard>-matnr ]-maktx ELSE '' )
    ).
    APPEND ls_final TO lt_final_raw.
  ENDLOOP.

  " 7) Aggregate stock by matnr/werks/lgort using REDUCE
  DATA(lt_final_agg) = VALUE STANDARD TABLE OF ty_final( ).
  lt_final_agg = REDUCE #( INIT tab = VALUE STANDARD TABLE OF ty_final( )
    FOR <row> IN lt_final_raw
    NEXT tab = VALUE #( BASE tab
      LET idx = line_index( tab[ matnr = <row>-matnr
                                 werks = <row>-werks
                                 lgort = <row>-lgort ] )
      IN
        IF idx IS INITIAL
          THEN VALUE #( BASE tab ( <row> ) )
          ELSE VALUE #( BASE tab
            ( CORRESPONDING #( <row> ) WITH { labst = tab[ idx ]-labst + <row>-labst } )
            EXCEPT tab[ idx ] )
    )
  ).

  gt_final = lt_final_agg.

ENDFORM.

FORM build_fieldcatalog.
  CLEAR gt_fcat.

  PERFORM add_fcat USING 'MATNR' 'Material'         'MATNR' '' 10 'X' ''.
  PERFORM add_fcat USING 'MAKTX' 'Description'      ''      '' 30 ''  ''.
  PERFORM add_fcat USING 'MTART' 'Type'             ''      ''  6 ''  ''.
  PERFORM add_fcat USING 'MEINS' 'UoM'              ''      ''  5 ''  ''.
  PERFORM add_fcat USING 'WERKS' 'Plant'            ''      ''  4 ''  ''.
  PERFORM add_fcat USING 'LGORT' 'Sloc'             ''      ''  4 ''  ''.
  PERFORM add_fcat USING 'LABST' 'Unrestricted'     ''      '' 13 ''  'X'. "do_sum

ENDFORM.

FORM add_fcat USING p_field p_text p_ref_tab p_ref_field p_outlen p_hotspot p_sum.
  CLEAR gs_fcat.
  gs_fcat-fieldname  = p_field.
  gs_fcat-seltext_m  = p_text.
  IF p_ref_tab IS NOT INITIAL.
    gs_fcat-ref_tabname  = p_ref_tab.
    gs_fcat-ref_fieldname= p_ref_field.
  ENDIF.
  IF p_outlen IS NOT INITIAL.
    gs_fcat-outputlen = p_outlen.
  ENDIF.
  IF p_hotspot = 'X'.
    gs_fcat-hotspot = 'X'.
  ENDIF.
  IF p_sum = 'X'.
    gs_fcat-do_sum = 'X'.
  ENDIF.
  APPEND gs_fcat TO gt_fcat.
ENDFORM.

FORM build_layout.
  CLEAR gs_layout.
  gs_layout-colwidth_optimize = 'X'.
  gs_layout-zebra             = 'X'.
  gs_layout-totals_text       = 'Totals'.
ENDFORM.

FORM build_events.
  CLEAR gt_events.

  gs_event-name = 'TOP_OF_PAGE'.
  gs_event-form = 'TOP_OF_PAGE'.
  APPEND gs_event TO gt_events.

ENDFORM.

FORM build_top_of_page.
  CLEAR gt_top.

  gs_top-typ  = 'H'.
  gs_top-info = text-t02. "Material Stock Overview
  APPEND gs_top TO gt_top.

  gs_top-typ  = 'S'.
  gs_top-key  = text-t03. "Filter
  gs_top-info = |MATNR:{ sy-uline } { sy-datum }|.
  APPEND gs_top TO gt_top.

  gs_top-typ  = 'A'.
  gs_top-info = |Language: { p_spras }  Max Rows: { p_max }|.
  APPEND gs_top TO gt_top.
ENDFORM.

FORM top_of_page.
  CALL FUNCTION 'REUSE_ALV_COMMENTARY_WRITE'
    EXPORTING
      it_list_commentary = gt_top.
ENDFORM.

FORM user_command USING r_ucomm     LIKE sy-ucomm
                        rs_selfield TYPE slis_selfield.

  CASE r_ucomm.
    WHEN '&IC1'. " hotspot or double-click
      IF rs_selfield-fieldname = 'MATNR' AND rs_selfield-value IS NOT INITIAL.
        SET PARAMETER ID 'MAT' FIELD rs_selfield-value.
        CALL TRANSACTION 'MM03' AND SKIP FIRST SCREEN.
      ENDIF.
  ENDCASE.

ENDFORM.